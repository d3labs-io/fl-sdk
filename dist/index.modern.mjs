import{ethers as t}from"ethers";import e from"axios";import{Validator as s}from"jsonschema";class n{constructor(t){this.jsonRpcProvider=void 0,this.jsonRpcProvider=t.jsonRpcProvider}async createWallet(){const e=t.Wallet.createRandom();return{address:e.address,privateKey:e.privateKey}}async getTransaction(e){const s=new t.JsonRpcProvider(this.jsonRpcProvider);return await s.getTransaction(e)}async getTransactionReceipt(e){const s=new t.JsonRpcProvider(this.jsonRpcProvider);return await s.getTransactionReceipt(e)}}class a{constructor(t){this.ipfsHttp=void 0,this.ipfsHttp=e.create({baseURL:t.ipfsUrl,headers:{Authorization:`Bearer ${t.ipfsToken}`}})}async uploadFile(t){const e=await this.ipfsHttp.postForm("/add",{file:t});if(e.status>=200&&e.status<300==0)throw new Error(`failed, status code: ${e.status}, status text: ${e.statusText}`);return e.data.cid}async getFile(t){const e=await this.ipfsHttp.get(`/ipfs/${t}`,{responseType:"arraybuffer"});if(e.status>=200&&e.status<300==0)throw new Error(`failed to fetch, status code: ${e.status}, message: ${e.statusText}`);return{fileBuffer:e.data,contentType:e.headers["content-type"]}}}var i=[{anonymous:!1,inputs:[{indexed:!1,internalType:"address",name:"add",type:"address"},{indexed:!1,internalType:"string",name:"symbol",type:"string"}],name:"Created",type:"event"},{inputs:[{internalType:"string",name:"name_",type:"string"},{internalType:"string",name:"symbol_",type:"string"}],name:"create",outputs:[],stateMutability:"nonpayable",type:"function"}],r=[{anonymous:!1,inputs:[{indexed:!0,internalType:"address",name:"from",type:"address"},{indexed:!0,internalType:"address",name:"to",type:"address"},{indexed:!0,internalType:"uint256",name:"tokenId",type:"uint256"}],name:"Transfer",type:"event"},{inputs:[{internalType:"address",name:"to",type:"address"},{internalType:"string",name:"uri",type:"string"}],name:"safeMint",outputs:[],stateMutability:"nonpayable",type:"function"},{inputs:[{internalType:"uint256",name:"tokenId",type:"uint256"}],name:"tokenURI",outputs:[{internalType:"string",name:"",type:"string"}],stateMutability:"view",type:"function"}];class o{constructor(t){this.jsonRpcProvider=void 0,this.nftFactoryAddress=void 0,this.ipfs=void 0,this.jsonRpcProvider=t.jsonRpcProvider,this.nftFactoryAddress=t.nftFactoryAddress,this.ipfs=new a(t)}async createSmartContract(e,s,n,a){const r=new t.JsonRpcProvider(this.jsonRpcProvider),o=new t.Wallet(e,r),p=new t.Contract(this.nftFactoryAddress,i,o),d=await p.create(s,n);if(a)return{trxHash:d.hash};const c=await d.wait();return{address:c.logs.find(t=>"Created"===t.fragment.name).args[0],trxHash:c.hash}}async mint(e,s,n,a){const i=new t.JsonRpcProvider(this.jsonRpcProvider),o=new t.Wallet(e,i),p=new t.Contract(s,r,o),d=await p.safeMint(o.getAddress(),n);return a?{trxHash:d.hash}:{tokenId:(await d.wait()).logs[0].args[2].toString(),trxHash:d.hash}}async getTokenURI(e,s){const n=new t.JsonRpcProvider(this.jsonRpcProvider),a=new t.Contract(e,r,n);return await a.tokenURI(s)}async generateMetadata(t){const e={name:t.name,description:t.description,timestamp:t.timestamp};if(t.file){const s=await this.ipfs.uploadFile(t.file);e.file=`ipfs://${s}`}const s=Buffer.from(JSON.stringify(e));return`ipfs://${await this.ipfs.uploadFile(s)}`}async getJSONMetadata(t,e){const s=await this.getTokenURI(t,e),{fileBuffer:n}=await this.ipfs.getFile(s.replace("ipfs://",""));return n.toString()}async getTokenFile(t,e){const s=await this.getJSONMetadata(t,e),n=JSON.parse(s);return n.file?await this.ipfs.getFile(n.file.replace("ipfs://","")):null}async checkMetadataSchema(t){const e=new s,n=JSON.parse(t);return e.validate(n,{title:"Token Metadata",type:"object",properties:{name:{type:"string"},description:{type:"string"},timestamp:{type:"number"},file:{type:"string",optional:!0}},required:["name","description","timestamp"],additionalProperties:!1}).valid}}class p{constructor(t){this.nfts=void 0,this.general=void 0,this.ipfs=void 0,this.nfts=new o(t),this.general=new n(t),this.ipfs=new a(t)}}export{p as SeaseedNFTSdk};
