import{ethers as t}from"ethers";import{Axios as e}from"axios";class s{constructor(t){this.jsonRpcProvider=void 0,this.jsonRpcProvider=t.jsonRpcProvider}async createWallet(){const e=t.Wallet.createRandom();return{address:e.address,privateKey:e.privateKey}}async getTransaction(e){const s=new t.JsonRpcProvider(this.jsonRpcProvider);return await s.getTransaction(e)}async getTransactionReceipt(e){const s=new t.JsonRpcProvider(this.jsonRpcProvider);return await s.getTransactionReceipt(e)}}class n{constructor(t){this.ipfsHttp=void 0,this.ipfsHttp=new e({baseURL:t.ipfsUrl,headers:{Authorization:`Bearer ${t.ipfsToken}`}})}async uploadFile(t){const e=new FormData;e.append("file",new Blob([t]));const s=await this.ipfsHttp.post("/add",e);if(s.status>=200&&s.status<300==0)throw new Error(`failed, status code: ${s.status}, status text: ${s.statusText}`);return JSON.parse(s.data).cid}async getFile(t){const e=await this.ipfsHttp.get(`/ipfs/${t}`,{responseType:"arraybuffer"});if(e.status>=200&&e.status<300==0)throw new Error(`failed to fetch, status code: ${e.status}, message: ${e.statusText}`);return{fileBuffer:e.data,contentType:e.headers["content-type"]}}}var a=[{anonymous:!1,inputs:[{indexed:!1,internalType:"address",name:"add",type:"address"},{indexed:!1,internalType:"string",name:"symbol",type:"string"}],name:"Created",type:"event"},{inputs:[{internalType:"string",name:"name_",type:"string"},{internalType:"string",name:"symbol_",type:"string"}],name:"create",outputs:[],stateMutability:"nonpayable",type:"function"}],r=[{anonymous:!1,inputs:[{indexed:!0,internalType:"address",name:"from",type:"address"},{indexed:!0,internalType:"address",name:"to",type:"address"},{indexed:!0,internalType:"uint256",name:"tokenId",type:"uint256"}],name:"Transfer",type:"event"},{inputs:[{internalType:"address",name:"to",type:"address"},{internalType:"string",name:"uri",type:"string"}],name:"safeMint",outputs:[],stateMutability:"nonpayable",type:"function"},{inputs:[{internalType:"uint256",name:"tokenId",type:"uint256"}],name:"tokenURI",outputs:[{internalType:"string",name:"",type:"string"}],stateMutability:"view",type:"function"}];class i{constructor(t){this.jsonRpcProvider=void 0,this.nftFactoryAddress=void 0,this.jsonRpcProvider=t.jsonRpcProvider,this.nftFactoryAddress=t.nftFactoryAddress}async createSmartContract(e,s,n,r){const i=new t.JsonRpcProvider(this.jsonRpcProvider),o=new t.Wallet(e,i),d=new t.Contract(this.nftFactoryAddress,a,o),p=await d.create(s,n);if(r)return{trxHash:p.hash};const c=await p.wait();return{address:c.logs.find(t=>"Created"===t.fragment.name).args[0],trxHash:c.hash}}async mint(e,s,n,a){const i=new t.JsonRpcProvider(this.jsonRpcProvider),o=new t.Wallet(e,i),d=new t.Contract(s,r,o),p=await d.safeMint(o.getAddress(),n);return a?{trxHash:p.hash}:{tokenId:(await p.wait()).logs[0].args[2].toString(),trxHash:p.hash}}async getTokenURI(e,s){const n=new t.JsonRpcProvider(this.jsonRpcProvider),a=new t.Contract(e,r,n);return await a.tokenURI(s)}}class o{constructor(t){this.nfts=void 0,this.general=void 0,this.ipfs=void 0,this.nfts=new i(t),this.general=new s(t),this.ipfs=new n(t)}}export{o as SeaseedNFTSdk};
